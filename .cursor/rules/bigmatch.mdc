---
alwaysApply: true
---

# üöÄ R√®gles Next.js v15 - Performance & Temps R√©el

## üìã Contexte du Projet

- Framework: Next.js v15 avec App Router
- Base de donn√©es: PostgreSQL + Prisma
- UI: React 18+ avec composants modernes
- Objectifs: Performance maximale, temps r√©el, optimisation des requ√™tes

---

## üéØ R√®gles de Performance Obligatoires

### 1. Structure des Composants

- TOUJOURS utiliser React Server Components par d√©faut
- Marquer explicitement "use client" UNIQUEMENT si n√©cessaire (hooks, √©v√©nements, state)
- Pr√©f√©rer les composants serveur pour les donn√©es statiques/semi-statiques
- √âviter les re-renders inutiles avec React.memo() pour les composants co√ªteux

### 2. Gestion des Donn√©es

- OBLIGATOIRE: Utiliser TanStack Query v5 pour toutes les requ√™tes c√¥t√© client
- OBLIGATOIRE: Impl√©menter le cache avec staleTime et gcTime appropri√©s
- Utiliser React Query DevTools en d√©veloppement
- Optimistic Updates pour les mutations critiques (scores, matchs)

### 3. Chargement et Streaming

- TOUJOURS utiliser loading.tsx pour les pages avec donn√©es
- Impl√©menter Suspense boundaries pour les composants async
- Utiliser streaming SSR avec { loading } pour les composants lents
- Pr√©charger les routes critiques avec next/link prefetch

### 4. Images et Assets

- OBLIGATOIRE: next/image pour toutes les images
- Sp√©cifier width/height explicitement
- Utiliser placeholder="blur" avec blurDataURL
- Optimiser les logos d'√©quipes avec sizes appropri√©s

---

## ‚ö° TanStack Query - Configuration Optimale

### Configuration Globale

```typescript
// lib/query-client.ts
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes
      retry: (failureCount, error) => {
        if (error.status === 404) return false;
        return failureCount < 3;
      },
      refetchOnWindowFocus: false,
      refetchOnReconnect: "always",
    },
    mutations: {
      retry: 1,
    },
  },
});
```

### Hooks Standards √† Cr√©er

- `useEvents()` - Cache 5min, refetch en arri√®re-plan
- `useMatches(eventId)` - Cache 1min, refetch automatique
- `useScores(matchId)` - Cache 30s, polling actif si match live
- `useRankings(eventId)` - Cache 2min, invalidation apr√®s match

### Patterns d'Optimisation

```typescript
// Bon: Prefetch des donn√©es critiques
const prefetchMatchData = () => {
  queryClient.prefetchQuery({
    queryKey: ["matches", eventId],
    queryFn: () => fetchMatches(eventId),
    staleTime: 60 * 1000,
  });
};

// Bon: Optimistic updates pour les scores
const updateScore = useMutation({
  mutationFn: updateMatchScore,
  onMutate: async (newScore) => {
    await queryClient.cancelQueries(["match", matchId]);
    const previousMatch = queryClient.getQueryData(["match", matchId]);
    queryClient.setQueryData(["match", matchId], newScore);
    return { previousMatch };
  },
  onError: (err, newScore, context) => {
    queryClient.setQueryData(["match", matchId], context.previousMatch);
  },
  onSettled: () => {
    queryClient.invalidateQueries(["match", matchId]);
  },
});
```

---

## üîÑ Temps R√©el - WebSockets & Server-Sent Events

### 1. Choix de la Technologie

- WebSockets via Socket.io pour les matchs en direct (scores, timer)
- Server-Sent Events pour les notifications moins critiques
- TanStack Query + polling pour les donn√©es semi-temps r√©el

### 2. Configuration Socket.io

```typescript
// lib/socket.ts
import { io } from "socket.io-client";

export const socket = io(process.env.NEXT_PUBLIC_WS_URL, {
  autoConnect: false,
  transports: ["websocket", "polling"],
  upgrade: true,
});

// Hook d'int√©gration avec React Query
export const useSocketSync = (matchId: string) => {
  const queryClient = useQueryClient();

  useEffect(() => {
    socket.on(`match:${matchId}:score`, (data) => {
      queryClient.setQueryData(["match", matchId], data);
    });

    socket.on(`match:${matchId}:timer`, (timerData) => {
      queryClient.setQueryData(["match", matchId, "timer"], timerData);
    });

    return () => {
      socket.off(`match:${matchId}:score`);
      socket.off(`match:${matchId}:timer`);
    };
  }, [matchId, queryClient]);
};
```

### 3. Polling Intelligent

```typescript
// Hook avec polling adaptatif
const useMatchWithPolling = (matchId: string) => {
  const { data: match } = useQuery({
    queryKey: ["match", matchId],
    queryFn: () => fetchMatch(matchId),
    refetchInterval: (data) => {
      if (data?.status === "LIVE") return 5000; // 5s si match live
      if (data?.status === "SCHEDULED") return 30000; // 30s si programm√©
      return false; // Pas de polling si termin√©
    },
  });

  return match;
};
```

---

## üóÉÔ∏è Optimisation Base de Donn√©es & APIs

### 1. Requ√™tes Prisma Optimis√©es

```typescript
// Bon: Include seulement les donn√©es n√©cessaires
const getEventWithMatches = async (eventId: string) => {
  return prisma.event.findUnique({
    where: { id: eventId },
    include: {
      teams: {
        select: { id: true, name: true, logo: true },
        orderBy: { name: "asc" },
      },
      matches: {
        where: { status: { in: ["SCHEDULED", "LIVE"] } },
        select: {
          id: true,
          scoreA: true,
          scoreB: true,
          status: true,
          teamA: { select: { id: true, name: true } },
          teamB: { select: { id: true, name: true } },
        },
      },
    },
  });
};

// √âviter: Over-fetching
// ‚ùå include: { teams: { include: { players: true } } }
```

### 2. Cache Strategy par Route API

```typescript
// app/api/events/[id]/route.ts
export async function GET(request, { params }) {
  const event = await getEventWithTeams(params.id);

  return NextResponse.json(event, {
    headers: {
      "Cache-Control": "public, s-maxage=300, stale-while-revalidate=60",
      "CDN-Cache-Control": "public, s-maxage=300",
    },
  });
}

// app/api/matches/[id]/scores/route.ts - Temps r√©el
export async function GET() {
  return NextResponse.json(scores, {
    headers: {
      "Cache-Control": "no-cache, must-revalidate",
    },
  });
}
```

### 3. Background Jobs avec Queues

```typescript
// lib/jobs/match-processor.ts - Pour les calculs lourds
import { Queue } from "bull";

export const matchQueue = new Queue("match processing");

matchQueue.process("updateRankings", async (job) => {
  const { eventId } = job.data;
  await recalculateRankings(eventId);

  // Invalider les caches pertinents
  await revalidateTag(`rankings:${eventId}`);
});

// D√©clencher apr√®s chaque match termin√©
export const triggerRankingUpdate = (eventId: string) => {
  matchQueue.add(
    "updateRankings",
    { eventId },
    {
      delay: 2000, // 2s de d√©lai
      removeOnComplete: 5,
      removeOnFail: 3,
    }
  );
};
```

---

## üîß Librairies Recommand√©es

### 1. Performance & State

```json
{
  "@tanstack/react-query": "^5.0.0",
  "@tanstack/react-query-devtools": "^5.0.0",
  "zustand": "^4.4.0",
  "immer": "^10.0.0",
  "react-hook-form": "^7.48.0",
  "zod": "^3.22.0"
}
```

### 2. Temps R√©el & Communication

```json
{
  "socket.io-client": "^4.7.0",
  "sse.js": "^2.3.0",
  "ws": "^8.14.0"
}
```

### 3. UI & Animations

```json
{
  "framer-motion": "^10.16.0",
  "react-intersection-observer": "^9.5.0",
  "react-virtualized-auto-sizer": "^1.0.0",
  "react-window": "^1.8.0"
}
```

### 4. Utils & Performance

```json
{
  "lodash-es": "^4.17.0",
  "date-fns": "^2.30.0",
  "bull": "^4.11.0",
  "ioredis": "^5.3.0",
  "sharp": "^0.32.0"
}
```

---

## üìè Patterns d'Optimisation Obligatoires

### 1. Code Splitting Intelligent

```typescript
// Lazy loading des composants lourds
const TournamentBracket = lazy(() => import("./TournamentBracket"));
const MatchTimer = lazy(() => import("./MatchTimer"));

// Pr√©charger les composants critiques
const prefetchComponents = () => {
  import("./TournamentBracket");
  import("./ScoreBoard");
};
```

### 2. Memoization Strat√©gique

```typescript
// M√©moiser les calculs co√ªteux
const ExpensiveChart = memo(({ data, filters }) => {
  const processedData = useMemo(() => {
    return heavyCalculation(data, filters);
  }, [data, filters]);

  return <Chart data={processedData} />;
});

// Callback stable pour √©viter re-renders
const useStableCallback = (callback, deps) => {
  return useCallback(callback, deps);
};
```

### 3. Virtualisation pour Grandes Listes

```typescript
import { FixedSizeList as List } from "react-window";

const VirtualizedRankings = ({ teams }) => (
  <List height={400} itemCount={teams.length} itemSize={60} itemData={teams}>
    {({ index, data, style }) => (
      <div style={style}>
        <RankingRow team={data[index]} />
      </div>
    )}
  </List>
);
```

---

## üö® Anti-Patterns √† √âviter

### ‚ùå Ne JAMAIS Faire

- Fetcher des donn√©es dans useEffect c√¥t√© client si disponible c√¥t√© serveur
- Utiliser useState pour des donn√©es serveur (utiliser TanStack Query)
- Oublier les key props dans les listes dynamiques
- Imbriquer des Suspense boundaries inutilement
- Polling constant sans condition d'arr√™t
- Mutations sans optimistic updates pour l'UX critique

### ‚úÖ Toujours Faire

- Pr√©f√©rer les Server Actions aux API routes quand possible
- Impl√©menter error boundaries pour la r√©silience
- Utiliser les TypeScript generics pour la type safety
- Validator les donn√©es avec Zod avant traitement
- Monitorer les performances avec Next.js Analytics
- Impl√©menter le retry logic pour les requ√™tes critiques

---

## üîç Monitoring & Debug

### 1. Performance Monitoring

```typescript
// lib/analytics.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from "web-vitals";

export const reportWebVitals = (metric) => {
  // Envoyer les m√©triques √† votre service d'analytics
  analytics.track("Web Vitals", {
    name: metric.name,
    value: metric.value,
    id: metric.id,
  });
};
```

### 2. Error Boundaries Globales

```typescript
"use client";
import { ErrorBoundary } from "react-error-boundary";

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert" className="error-boundary">
      <h2>Oups, une erreur s'est produite!</h2>
      <button onClick={resetErrorBoundary}>R√©essayer</button>
    </div>
  );
}

export default function RootErrorBoundary({ children }) {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>{children}</ErrorBoundary>
  );
}
```

---

## ‚öñÔ∏è R√®gles de Commit

- Pr√©fixer les commits: feat:, fix:, perf:, refactor:
- Tester les Web Vitals avant chaque push
- V√©rifier que les queries TanStack Query ont des keys appropri√©es
- S'assurer que les composants Server/Client sont bien d√©limit√©s
- Valider les performances avec Lighthouse (score > 90)

**üéØ Objectif: Application ultra-rapide, temps r√©el fluide, exp√©rience utilisateur exceptionnelle!**
